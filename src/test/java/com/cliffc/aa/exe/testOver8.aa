// One DynLoad, fcn needs DynTable
// Type: ( int64, flt64)
// Eval: ( 3, 3.3f)


// Root
// fcn = { $dyn2 ->  // [[ DYN -> resolved ]]
//   @{
//      qii = { ---- x y -> (+ ---- (+1  ---- x) (+1  ---- y)) };
//      qif = { ---- x y -> (+ ---- (+1  ---- x) (f2i ---- y)) };
//      qfi = { ---- x y -> (+ ---- (f2i ---- x) (+1  ---- y)) };
//      qff = { ---- x y -> (+ ---- (f2i ---- x) (f2i ---- y)) };
//   }._[$dyn2]
// };
// bar = { $dyn x ->  // [[ APPLY0: [[ DYN -> resolved]], APPLY1: [[DYN -> resolved]] ]]
//   if 1 ? ((fcn $dyn.APPLY0) ---- x 2) : ((fcn $dyn.APPLY1) ---- x 2.2f)
// };
// baz = { $dyn ->    // [[ APPLY2: [[ APPLY0,APPLY1]], APPLY4: [[ APPLY0,APPLY1]] ]]
//   if 0 ? (bar $dyn.APPLY2 3) : (bar $dyn.APPLY4 3.9f)
// };
// def$dyn should be a nested table
// [[ APPLY2: [[ APPLY0,APPLY1]], APPLY4: [[ APPLY0,APPLY1]] ]] 
// (baz def$dyn)


fcn = { ->
  @{
     qii={ x y -> (+ (+1  x) (+1  y)) }; // i i -> i
     qif={ x y -> (+ (+1  x) (f2i y)) }; // i f -> i
     qfi={ x y -> (+ (f2i x) (+1  y)) }; // f i -> i
     qff={ x y -> (+ (f2i x) (f2i y)) }; // f f -> i
  }._    // Which of {q*} should be picked?
};

bar = { x ->
  if 1
  ? ((fcn) x 2   )  // Picks [D0:qii/qfi]
  : ((fcn) x 2.2f)  // Picks [D0:qif/qff]
};

baz = { ->
  if 0
  ? (bar 3   )  // Passing in int
  : (bar 3.9f)  // Passing in flt
};
(baz)
  

