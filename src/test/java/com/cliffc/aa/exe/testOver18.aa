// Check wrapped prims
// Type: Unresolved dynamic field
// Eval: CRASH
fwrap = { ff ->
  @{ f = ff;
     is0 = (f> 1.0f ff);
     mul = @{
       fimul = { y0 -> (fwrap (f* ff (i2f y0.i))) };
       ffmul = { y1 -> (fwrap (f* ff      y1.f )) };
     };
     sub = @{
       fisub = { y2 -> (fwrap (f- ff (i2f y2.i))) };
       ffsub = { y3 -> (fwrap (f- ff      y3.f )) };
     };
   }
};

iwrap = { ii ->
  @{ i = ii;
     is0 = (== ii 0);
     mul = @{
       iimul = { y4 -> (iwrap ( *      ii  y4.i)) };
       ifmul = { y5 -> (fwrap (f* (i2f ii) y5.f)) };
     };
     sub = @{
       iisub = { y6 -> (iwrap ( -      ii  y6.i)) };
       ifsub = { y7 -> (fwrap (f- (i2f ii) y7.f)) };
     };
   }
};

( { n22 ->
    (n22.mul._ // pattern sees an int, so matches fimul
      ( { n12 ->
          // should type as a blend of iwrap,fwrap
          // types as: @{ is0=int64; mul=( ); }
           if n12.is0
           ? (iwrap 1)        // returns iwrap
           : (n12.mul.fimul @{ i =1; } )  // returns fwrap
        }  // returns a blend of iwrap,fwrap; { [[]] D:@{ is0=int64; mul=( ); } -> D }
        // either fwrap.sub.fisub or iwrap.sub.iisub
        (n22.sub._ @{ i = 1; } )  // matches fisub
      ) // returns iwrap or fwrap again, so yeah: D:@{ is0=int64; mul=( ); }
    )
  }
  (fwrap 2.2f)
)


// --------------------------
// First time D138 matches:
// D138 rejects ffmul because PATTERN uses INT64.
// D138 matches fimul because PATTERN uses INT64.
// I:@{ ffmul={->}; fimul={->}; }

// Match on "fimul":
// MATCH:   A:{ [[]]   @{ i=int64;  ...,                                  } -> B:@{FLT_STUFF} }
// PATTERN:   { [[]] D:@{ i=int64; is0=int64; mul=@{STUFF}; sub=@{STUFF}; } ->   V86          }
// Unifies MATCH and PATTERN, forcing PATTERN FIELDS INTO MATCH.

