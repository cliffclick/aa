// One DynLoad, no Fresh, resolves local
// Type: ( 4, 4.4f)
// Eval: ( 4, 4.4f)
inc = @{ iinc ={ x -> (+ x 1) }; finc ={ x -> (f+ x 1.1f)}; };
(pair (inc._ 3) (inc._ 3.3f))


//    // Simpler overload tests
//    test("!(2,3.14)._","nil","int:int1", null, null, null, null);
//    test("(2,3.14)._.sin()","flt:0.0015926529164868282","flt:flt64", null, null, null, null);
//    // Two DynLoads, two Fresh
//    test("q=(2,3.14); (!q._,q._.sin())","*[16](_, nil, flt:0.0015926529164868282)","*[16](_,int:int1,flt:flt64)", null, null, "[16]", null);
//    // One DynLoad, one Fresh, Function in-between
//    test("noinline_f={(2,3.14)._}; noinline_f().sin()","flt:0.0015926529164868282","flt:flt64", null, null, null, null);
//    // One DynLoad, one Fresh, Function in-between, plus 2nd DynLoad on Bang
//    test("noinline_f={(2,3.14)._}; !noinline_f()","nil","int:int1", null, null, null, null);
//    // One DynLoad but Freshed twice plus 2nd DynLoad on Bang
//    test("noinline_f={(2,3.14)._}; (!noinline_f(),noinline_f().sin())","*[16](_, nil, flt:0.0015926529164868282)","*[16](_,int:int1,flt:flt64)", null, null, "[16]", null);
//
//    // Simpler test, just return a struct with 1 field, and pick the struct/field
//    test("""
//            noinline_foo = {
//                    ( @{ a=1 },
//                      @{ b=2 }
//              )._
//            };
//            math.rand(2) ? noinline_foo().a : noinline_foo().b
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // Simpler test, just X no Y
//    test("""
//            noinline_foo = { x ->
//                    ( { x -> !x },
//                      { x -> x.sin() }
//              )._(x)
//            };
//            math.rand(2) ? noinline_foo(3) : noinline_foo(3.3)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // open bugs: return from foo is int:%[][5,6] - a mix of int & float
//    // but the clazz is INT not a blend of INT/FLT
//
//    // bug store of noinline_foo does not replace the prior store of ANY in
//    // the new field slot
//    test("""
//            noinline_foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            math.rand(2) ? noinline_foo(3,5) : noinline_foo(3.3,5)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // Open bug: foo inlines here but not in the next case below.
//    // Surprised foo inlines.
//    test("""
//            foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            math.rand(2) ? foo(3,5) : foo(3.3,5)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    test("""
//            foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            baz = { x -> foo(x,5) };
//            math.rand(2) ? baz(3) : baz(3.3)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//
//    test(
//"""
//foo = { x y ->
//        ( { x y -> !x * !y },
//          { x y -> !x *  y.sin(3.14) },
//          { x y -> x.sin(3.14) * !y },
//          { x y -> x.sin(3.14) *  y.sin(3.14) }
//  )._(x,y)
//};
//baz = { x -> math.rand(2) ? foo(x,2) : foo(x,2.2) };
//bar = {   -> math.rand(2) ? baz(  3) : baz  (3.3) };
//bar()
//""",
//         "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);

