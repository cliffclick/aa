// One DynLoad, fcn needs DynTable
// Type: ( int64, flt64)
// Eval: ( 3, 3.3f)

// DT: [D0: A]
fcn = { -> @{ i=2; f=2.3f; }._ };
//       [D0: int]        [D0: flt]
(pair (+ (fcn    ) 1) (f+ (fcn    ) 1.1f))




/*
$dyn = Root;  // $dyn is [ F0:D0:int:"i", F1:D0:flt:"f" ]
fcn = { $dyn -> @{ i=2; f=2.3f; }._ };
(pair (+ (fcn[$dyn]) 1) (f+ (fcn[$dyn]) 1.1f))
 */




//    // Simpler overload tests
//    test("!(2,3.14)._","nil","int:int1", null, null, null, null);
//    test("(2,3.14)._.sin()","flt:0.0015926529164868282","flt:flt64", null, null, null, null);
//    // Two DynLoads, two Fresh
//    test("q=(2,3.14); (!q._,q._.sin())","*[16](_, nil, flt:0.0015926529164868282)","*[16](_,int:int1,flt:flt64)", null, null, "[16]", null);
//    // One DynLoad, one Fresh, Function in-between
//    test("noinline_f={(2,3.14)._}; noinline_f().sin()","flt:0.0015926529164868282","flt:flt64", null, null, null, null);
//    // One DynLoad, one Fresh, Function in-between, plus 2nd DynLoad on Bang
//    test("noinline_f={(2,3.14)._}; !noinline_f()","nil","int:int1", null, null, null, null);
//    // One DynLoad but Freshed twice plus 2nd DynLoad on Bang
//    test("noinline_f={(2,3.14)._}; (!noinline_f(),noinline_f().sin())","*[16](_, nil, flt:0.0015926529164868282)","*[16](_,int:int1,flt:flt64)", null, null, "[16]", null);
//
//    // Simpler test, just return a struct with 1 field, and pick the struct/field
//    test("""
//            noinline_foo = {
//                    ( @{ a=1 },
//                      @{ b=2 }
//              )._
//            };
//            math.rand(2) ? noinline_foo().a : noinline_foo().b
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // Simpler test, just X no Y
//    test("""
//            noinline_foo = { x ->
//                    ( { x -> !x },
//                      { x -> x.sin() }
//              )._(x)
//            };
//            math.rand(2) ? noinline_foo(3) : noinline_foo(3.3)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // open bugs: return from foo is int:%[][5,6] - a mix of int & float
//    // but the clazz is INT not a blend of INT/FLT
//
//    // bug store of noinline_foo does not replace the prior store of ANY in
//    // the new field slot
//    test("""
//            noinline_foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            math.rand(2) ? noinline_foo(3,5) : noinline_foo(3.3,5)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // Open bug: foo inlines here but not in the next case below.
//    // Surprised foo inlines.
//    test("""
//            foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            math.rand(2) ? foo(3,5) : foo(3.3,5)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    test("""
//            foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            baz = { x -> foo(x,5) };
//            math.rand(2) ? baz(3) : baz(3.3)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//
//    test(
//"""
//foo = { x y ->
//        ( { x y -> !x * !y },
//          { x y -> !x *  y.sin(3.14) },
//          { x y -> x.sin(3.14) * !y },
//          { x y -> x.sin(3.14) *  y.sin(3.14) }
//  )._(x,y)
//};
//baz = { x -> math.rand(2) ? foo(x,2) : foo(x,2.2) };
//bar = {   -> math.rand(2) ? baz(  3) : baz  (3.3) };
//bar()
//""",
//         "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);

