// One DynLoad, fcn needs DynTable
// Type: ( int64, flt64)
// Eval: ( 3, 3.3f)

// DT: { [D0=A] -> A }
fcn = { $dsp ->
  @{
     qii={ x y -> (+ (+1  x) (+1  y)) } // i i -> i
     qif={ x y -> (+ (+1  x) (f2i y)) } // i f -> i
     qfi={ x y -> (+ (f2i x) (+1  y)) } // f i -> i
     qff={ x y -> (+ (f2i x) (f2i y)) } // f f -> i
  }._    // Which of {w,x,y,z} should be picked?
};

// DT: [ F0= [D0=qii/qfi]
//       F1= [D0=qfi/qff] ]
bar = { $dsp x 
->
  if rnd
  ? ((fcn $dsp.F0) x 2   )  // F0: Picks [D0:qii/qfi]
  : ((fcn $dsp.F1) x 2.2f)  // F1: Picks [D0:qif/qff]
}

// Structure of a DynTable after matching
// DT: [ [F3: [F0:[D0:qii],F1:[D0:qif]]]
//       [F4: [F0:[D0:qfi],F1:[D0:qff]]] ]
baz = { ->
  if rnd
  ? (bar 3)     // F3: Passing in [F0:[D0:qii],F1:[D0:qif]]
  : (bar 3.3f)  // F4: Passing in [F0:[D0:qfi],F1:[D0:qff]]
}







//    // Simpler overload tests
//    test("!(2,3.14)._","nil","int:int1", null, null, null, null);
//    test("(2,3.14)._.sin()","flt:0.0015926529164868282","flt:flt64", null, null, null, null);
//    // Two DynLoads, two Fresh
//    test("q=(2,3.14); (!q._,q._.sin())","*[16](_, nil, flt:0.0015926529164868282)","*[16](_,int:int1,flt:flt64)", null, null, "[16]", null);
//    // One DynLoad, one Fresh, Function in-between
//    test("noinline_f={(2,3.14)._}; noinline_f().sin()","flt:0.0015926529164868282","flt:flt64", null, null, null, null);
//    // One DynLoad, one Fresh, Function in-between, plus 2nd DynLoad on Bang
//    test("noinline_f={(2,3.14)._}; !noinline_f()","nil","int:int1", null, null, null, null);
//    // One DynLoad but Freshed twice plus 2nd DynLoad on Bang
//    test("noinline_f={(2,3.14)._}; (!noinline_f(),noinline_f().sin())","*[16](_, nil, flt:0.0015926529164868282)","*[16](_,int:int1,flt:flt64)", null, null, "[16]", null);
//
//    // Simpler test, just return a struct with 1 field, and pick the struct/field
//    test("""
//            noinline_foo = {
//                    ( @{ a=1 },
//                      @{ b=2 }
//              )._
//            };
//            math.rand(2) ? noinline_foo().a : noinline_foo().b
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // Simpler test, just X no Y
//    test("""
//            noinline_foo = { x ->
//                    ( { x -> !x },
//                      { x -> x.sin() }
//              )._(x)
//            };
//            math.rand(2) ? noinline_foo(3) : noinline_foo(3.3)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // open bugs: return from foo is int:%[][5,6] - a mix of int & float
//    // but the clazz is INT not a blend of INT/FLT
//
//    // bug store of noinline_foo does not replace the prior store of ANY in
//    // the new field slot
//    test("""
//            noinline_foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            math.rand(2) ? noinline_foo(3,5) : noinline_foo(3.3,5)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    // Open bug: foo inlines here but not in the next case below.
//    // Surprised foo inlines.
//    test("""
//            foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            math.rand(2) ? foo(3,5) : foo(3.3,5)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//    test("""
//            foo = { x y ->
//                    ( { x y -> !x * !y },
//                      { x y -> x.sin() * !y }
//              )._(x,y)
//            };
//            baz = { x -> foo(x,5) };
//            math.rand(2) ? baz(3) : baz(3.3)
//            """,
//            "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);
//
//
//    test(
//"""
//foo = { x y ->
//        ( { x y -> !x * !y },
//          { x y -> !x *  y.sin(3.14) },
//          { x y -> x.sin(3.14) * !y },
//          { x y -> x.sin(3.14) *  y.sin(3.14) }
//  )._(x,y)
//};
//baz = { x -> math.rand(2) ? foo(x,2) : foo(x,2.2) };
//bar = {   -> math.rand(2) ? baz(  3) : baz  (3.3) };
//bar()
//""",
//         "*[13](_,int:4,flt:4.840000000000001)","*[15](int64,flt64)", null, null, "[14]", null);

