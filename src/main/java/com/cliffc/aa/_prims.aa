// aa source to define the primitives.  Unlike normal aa, this code allows
// $$JavaClassName; the Java class function "clazz_node" returns a Node.
// Typically used in the call position, with a FunPtrNode returned.

int = : @{
  _val : $#com.cliffc.aa.type.TypeInt$INT64;

  // Unary ops
  -_ = { -> int($$com.cliffc.aa.node.PrimNode$MinusI64(_val)) };
  !_ = { -> int($$com.cliffc.aa.node.PrimNode$Not(_val)) };
  
  // Simple integer math
  _+_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$AddI64(_val,y._val)) };
  _-_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$SubI64(_val,y._val)) };
  _*_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$MulI64(_val,y._val)) };
  //_/_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$DivI64(_val,y._val)) };
  //_%_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$ModI64(_val,y._val)) };
  
  _+_  = { y:flt -> flt($$com.cliffc.aa.node.PrimNode$AddF64($$com.cliffc.aa.node.PrimNode$ConvertI64F64(_val),y._val)) };

  // Integer relations
  _<_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$LT_I64(_val,y._val)) };
  _<=_ = { y:int -> int($$com.cliffc.aa.node.PrimNode$LE_I64(_val,y._val)) };
  _>_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$GT_I64(_val,y._val)) };
  _>=_ = { y:int -> int($$com.cliffc.aa.node.PrimNode$GE_I64(_val,y._val)) };
  _==_ = { y:int -> int($$com.cliffc.aa.node.PrimNode$EQ_I64(_val,y._val)) };
  _!=_ = { y:int -> int($$com.cliffc.aa.node.PrimNode$NE_I64(_val,y._val)) };

  //_<_  = { y:flt -> int($$com.cliffc.aa.node.PrimNode$LT_F64($$com.cliffc.aa.node.PrimNode$ConvertI64F64(_val),y._val)) };
  //_<=_ = { y:flt -> int($$com.cliffc.aa.node.PrimNode$LE_F64($$com.cliffc.aa.node.PrimNode$ConvertI64F64(_val),y._val)) };
  //_>_  = { y:flt -> int($$com.cliffc.aa.node.PrimNode$GT_F64($$com.cliffc.aa.node.PrimNode$ConvertI64F64(_val),y._val)) };
  //_>=_ = { y:flt -> int($$com.cliffc.aa.node.PrimNode$GE_F64($$com.cliffc.aa.node.PrimNode$ConvertI64F64(_val),y._val)) };
  //_==_ = { y:flt -> int($$com.cliffc.aa.node.PrimNode$EQ_F64($$com.cliffc.aa.node.PrimNode$ConvertI64F64(_val),y._val)) };
  //_!=_ = { y:flt -> int($$com.cliffc.aa.node.PrimNode$NE_F64($$com.cliffc.aa.node.PrimNode$ConvertI64F64(_val),y._val)) };

};

flt = : @{
  _val : $#com.cliffc.aa.type.TypeFlt$FLT64;

  _+_  = { y:flt -> flt($$com.cliffc.aa.node.PrimNode$AddF64(_val,y._val)) };
  _+_  = { y:int -> flt($$com.cliffc.aa.node.PrimNode$AddF64(_val,$$com.cliffc.aa.node.PrimNode$ConvertI64F64(y._val))) };
  
  // Float relations
  _<_  = { y:flt -> int($$com.cliffc.aa.node.PrimNode$LT_F64(_val,y._val)) };
  //_<=_ = { y:flt -> int($$com.cliffc.aa.node.PrimNode$LE_F64(_val,y._val)) };
  //_>_  = { y:flt -> int($$com.cliffc.aa.node.PrimNode$GT_F64(_val,y._val)) };
  //_>=_ = { y:flt -> int($$com.cliffc.aa.node.PrimNode$GE_F64(_val,y._val)) };
  //_==_ = { y:flt -> int($$com.cliffc.aa.node.PrimNode$EQ_F64(_val,y._val)) };
  //_!=_ = { y:flt -> int($$com.cliffc.aa.node.PrimNode$NE_F64(_val,y._val)) };

  _<_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$LT_F64(_val,$$com.cliffc.aa.node.PrimNode$ConvertI64F64(y._val))) };
  //_<=_ = { y:int -> int($$com.cliffc.aa.node.PrimNode$LE_F64(_val,$$com.cliffc.aa.node.PrimNode$ConvertI64F64(y._val))) };
  //_>_  = { y:int -> int($$com.cliffc.aa.node.PrimNode$GT_F64(_val,$$com.cliffc.aa.node.PrimNode$ConvertI64F64(y._val))) };
  //_>=_ = { y:int -> int($$com.cliffc.aa.node.PrimNode$GE_F64(_val,$$com.cliffc.aa.node.PrimNode$ConvertI64F64(y._val))) };
  //_==_ = { y:int -> int($$com.cliffc.aa.node.PrimNode$EQ_F64(_val,$$com.cliffc.aa.node.PrimNode$ConvertI64F64(y._val))) };
  //_!=_ = { y:int -> int($$com.cliffc.aa.node.PrimNode$NE_F64(_val,$$com.cliffc.aa.node.PrimNode$ConvertI64F64(y._val))) };

};
  
//int1  =: $$com.cliffc.aa.type.TypeInt#BOOL;
//flt32 =: $$com.cliffc.aa.type.TypeFlt#FLT32;
//flt64 =: $$com.cliffc.aa.type.TypeFlt#FLT64;
//ptr   =: $$com.cliffc.aa.type.TypeMemPtr#ISUSED;
//str   =: $$com.cliffc.aa.type.TypeMemPtr#STRPTR;
//ary   =: $$com.cliffc.aa.type.TypeMemPtr#ARYPTR;
//// TODO: Some way in the parser to specify RHS should be thunked.
//// Then can drop the primitives and write:
////_&&_ = { pred thunk:lazy -> pred ? thunk() : 0    }
////_||_ = { pred thunk:lazy -> pred ? pred : thunk() }
//_&&_ = { pred thunk -> $$com.cliffc.aa.node.PrimNode$AndThen(pred,thunk); };
//_||_ = { pred thunk -> $$com.cliffc.aa.node.PrimNode$OrElse (pred,thunk); };
//// Pointer ==
//_==_ = { x:ptr? y:ptr? -> $$com.cliffc.aa.node.PrimNode$EQ_OOP(x,y) };
//_!=_ = { x:ptr? y:ptr? -> $$com.cliffc.aa.node.PrimNode$NE_OOP(x,y) };
//
//// Convert to str
//str = { x:int -> $$com.cliffc.aa.node.NewStrNode$ConvertI64Str(x) };
//str = { x:flt -> $$com.cliffc.aa.node.NewStrNode$ConvertF64Str(x) };
//str = { x:str? -> x };
//
//// String concat
//_+_ = { x:str? y:str? -> $$com.cliffc.aa.node.NewStrNode$AddStrStr(x,y) };
//
//
//// --------------
//// Arrays
//#_  = { ary:ary -> $$com.cliffc.aa.node.MemPrimNode$LValueLength(ary) };
//[_] = { len:int -> $$com.cliffc.aa.node.NewAryNode$NewAry(len) };
//
//// --------------
//// Math
//math = @{
//  pi = $$com.cliffc.aa.node.ConNode$PI;
//  rand = { x:int -> $$com.cliffc.aa.node.PrimNode$RandI64(x) };
//};

// end of file
